集合框架最好结合源代码看，只看关键的方法。要记住要点，能讲出来
有任何不懂的地方，提出来一起讨论

- ArrayList
  1. ArrayList初始容量为10， 每当add操作时，先检查容量是否满，如果满，扩容1.5倍。
  2. 扩容的实现：新建一个数组，遍历新数组，将当前数组按索引取出来，添加到新数组中。
  3. ArrayList是基于Object数组的。
  4. ArrayList 的性能消耗主要来源于扩容和固定位置的增删。ArrayList固定位置增删，都会导致全量拷贝。(System.copyarray)。
  5. ArrayList的顺序添加和查询，效率为O(1)，效率很好。固定位置增删的复杂度是O(n)
  6. ArrayList 创建的时候 需要考虑是否要初始化最小容量，以此避免扩容带来的消耗。

- LinkedList
  1. 存储：使用链表。因此具有链表的特性。
  2. 插入和删除都只需要改变链表的索引，不需要移动数据。
  3. 插入与删除效率高。
  4. 查询要遍历所有的节点，因此查询慢
- Vector
  ArrayList的每一个方法都加上synchronized关键字。线程安全。效率很低，不建议使用。

- HashMap(完美秒杀版 要结合源码一起看)
  http://www.2cto.com/kf/201505/401433.html
  1. hash结构：数组 +　链表 +　红黑树的实现
      load_factor 加载因子，用来表示填充比(maxCapacity/size) 0.75f
        也就是说，当hashMap的数组装满超过75%的元素，就要扩容。
      DEFAULT_INITIAL_CAPACITY 初始化的默认容量：16
      TREEIFY_THRESHOLD 固定设置为8.当一个桶的节点的个数超过8个，如果继续使用链表的复杂度为O(n)，性能会下降
        因此要将链表替换成红黑树。log(n)
      UNTREEIFY_THRESHOLD 固定设置为6.当resize时，根据这个字段判断是否要讲红黑树拆成链表。
  2. 扩容：当到达数组的75%时，扩容。将容量调整为原来的两倍，其实现原理是新建一个两倍容量的数组，将当前数组拷贝到新数组中。
      可见扩容很耗时
  3. hash计算：先由key值通过hash(key)得到h，然后h&(length - 1)得到位置。
     一般对于哈希表的散列常用的方法有直接定址法，除留余数法等，既要便于计算，又能减少冲突。
     在Hashtable中就是通过除留余数法散列分布的，具体如下：`int index = (hash & 0x7FFFFFFF) % tab.length;`
     hash函数的实现： (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)
     hashcode 无符号右移16位，再跟hashcode异或运算
     http://www.2cto.com/kf/201505/401433.html
  4.填充比load_factor: 填充比大，说明装的更满，空间利用率高，但是查找效率低。
      填充比小，空间利用率低，冲突的概率更低，效率更高(可能)。空间利用率和查找效率要有平衡。
  5. putVal方法:
     1) 检测tab[]是否为null，如果为null，resize()，分配内存。
     2) 将入参key进行hash计算，得到索引i，检查tab[i]是否为null，如果是则直接添加，否则说明检测到冲突。下一步处理冲突
     3) 处理冲突：先hash计算得到索引，如果发现该索引已被占用，检测第一个节点的类型(链表或者红黑树的第一个节点)，
              将新节点挂在链表或者红黑树上

- Set
  1. HashSet 基于HashMap的实现，因此HashSet也具有HashMap的大部分特性
     将集合元素作为key值存入hashMap， 将静态对象Object PRESENT作为Value存入hashMap
     查找复杂度：如果不冲突，复杂度为O(1)， 如果冲突，如果桶为链表，复杂度为O(n)，如果为红黑树，复杂度为O(logn)
  2. HashSet的存储原理是将元素作为key存入hashMap，因此不能存储相同的元素。

- LinkedHashMap
  1. 基于链表的HashMap的实现。桶的每一个节点都是链表的节点，该节点保存了当前上一个节点和下一个节点的引用。
     因此是有序的。

-- 值传递和引用传递
http://guhanjie.iteye.com/blog/1683637