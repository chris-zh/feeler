1. 原子性，可见性
原子性：指的是一个操作是不可分割的，就说它具有原子性.可以通过同步技术让非原子性的操作变成原子性操作。
比如 int i = i + 1;是一个非原子性操作：先读取i的值，给i+1，再给i赋值。

可见性：一个线程修改了一个共享变量，另一个线程马上可以观测到修改的结果。volatile可以保证可见性，不能保证原子性
volatile的作用：
1. 保证可见性
2. 禁止重排序
todo


2. wait, notify, notifyAll的使用
在多线程中，可以把一个对象作为事件对象。通过这个对象的wait，notify, notifyAll来完成线程之间的状态通知。
notify会唤醒一个等待中的线程，notifyAll会唤醒所有的等待线程。

3. memcached
基于Key-Value的散列表,通过CRC计算键值，将内容存储在不同的机器上。当散列表满了之后，通过LRU机制淘汰掉一部分内容，用以存储
新的内容。基于libevent.

4. 乐观锁，悲观锁
http://www.cnblogs.com/lcngu/p/5405890.html
乐观锁的思路：每次不加锁，认为没有冲突去完成某项操作。如果失败就重试(循环)，直到成功为止。
java.util.concurrent下的原子类使用硬件提供的CAS机制实现同步就是乐观锁的实践。
乐观锁的实现：用CAS指令Unsafe类提供的基于CAS机制的native方法
悲观锁的思路：独占锁都是悲观锁，假设最坏的情况，确保只有没有冲突的时候才去执行，导致其他所有线程挂起，等待持有锁的线程释放锁。
悲观锁的缺陷：线程挂起和恢复的过程存在很大的开销，代价很大。